## S8 BFD & Dijkstra & DFS (backtracing)
1. All possible solution，遍历算法，两种，BFS和DFS
2. BFS和DFS相互转换
3. BFS
   - 先来后到进行遍历，neighs依次遍历，使用queue
   - 通过额外的变量记录层数步数，e.g.石头砸湖，涟漪的距离
     - 第一种方法，交替使用两个queue。当前queue所poll出的consume之后产生新的都丢到一个新的queue里，当当前的queue空了，说明这层完了，该下一层了
     - 第二种方法，标记level的最后一个val（或者第一个val）。比如标记第一个，先把第一个val标记成第一层的第一个，当tree level order traverse时，遇到标记，我们知道新的level开始了，同时立刻把这个开始的left child标记成第一个，这个left child就是下个level的第一个。但是有时候下一层的第一个可能不一定是当前第一个的left child，可能没有，right child也可能没有，比较麻烦
     - 第三个方法，使用每层的size。先把起点的size cache下来，for loop这个size，for loop 完说明第一个level结束，此时queue放进去的就是下一层的所有element，所以把这个queue的size cache下来作为新的一层的size，再次for loop从queue拿出这个size个的element，拿完说明当前level遍历完，而此时queue里又是下一层所有element，以此类推
   - BFS起点可以多个，e.g. 多个石头砸湖
   - BFS步骤：
     - step1：push root
     - step2：expand/queue.poll(), visit, print, use
     - step3: generate neighs and offer them to the queue
   - 注意while loop的终止条件？要遍历所有的话，终止条件是queue是否为空；或者其他特定条件，找到target，或者第k个什么的
4. Level order traverse Tree --> BFS
5. Dijkstra's Algorithm
   - Dijkstra Algorithm is used to find the shortest path from one node to any other node in graph
## Q1 Binary Tree Level Order Traversal (L102)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q1.1 do it by DFS
     - 使用hashmap记录key value pair，key是层数，value是该层的element所组成的一个list
       - DFS遍历过程中要记录层数，然后准备往hashmap里放：
         - 当当前层数所对应的hashmap的key value pair没有时，说明这时候遍历到的是新的层的第一个
         - 如果hashmap中有，则把这个element接到这个key层数所对应的list的后面
     - hashmap可以换成list of list，因为这里level层数就是0，1，2，直接可以对应到list的index
   - Q1.2 L107 do it by bottom up
     - 正常level order traverse，然后```Collections.reverse(result);```
   - Q1.3 L314 Binary Tree Vertical Order Traversal
     - 这里类似之前使用DFS遍历，也是建立一个vertical位置到各个node的一一对应关系
     - 所以本质上BFS也是可以在遍历过程中得到当前node的vertical位置，然后丢到hashmap中
     - 这里vertical位置可以是root为0，left child就-1，right child就加1，在遍历过程中，generate新的node时就可以根据-1和+1得到所对应的vertical level来放入hashmap
     - 如果是使用BFS，一个queue放element，一个queue放vertical位置，保证这两个queue中的内容consistent
     - 更general是把node和vertical信息 wrap到一个object中
     - 由于输出要有顺序，所以在整体的遍历过程中，要有两个global variable来记录min和max，也就是两个边界，在得到hashmap后用这两个边界来有序的输出element
   - Q1.4 Level Order Traversal from right to left
     - generate 下一层的node放入queue时，先把right child放入queue再把left child放入queue
   - Q1.5 leaf nodes order traversal
     - 输出当前leaf node，然后假设没了这些已经输出的leaf node，再次输出此时的leaf node
     - hashmap记录以当前node为root的的subtree的高度，这个高度即为leaf node输出的level，本身是leaf node的树高为1，所以应该第一个输出
     - 可以在DFS做get height的过程中，call 左右height之后，把call出来的height放进这个global的hashmap中
   - Q1.6 seeing from left or right
     - BFS level order traverse，分层for loop遍历时，当是当前层数的第一个就加到result list中，则是see from left；当是最后一个时，就加到result list中，则是see from right
     - see from top or bottom：就是vertical traverse的第一个/最后一个
### S1
1. Ideas：
   - BFS 不分层
2. Comments:
   - null
3. Code
```java
public void levelOrderTraversal(TreeNode root) { 
	if (root == null) {
		return;
    }
    Queue<TreeNode> que = new LinkedList<>();
    que.offer(root);
    while (!que.isEmpty()) {
        TreeNode pollNode = que.poll();
        //?
        System.out.println(pollNode.value); //visit 

        if (pollNode.left != null) {// 这里先判断是否是null，没有就不会加，所以从q里poll出来的永远都是非null
            que.offer(pollNode.left);// 同样，这里可以无脑都丢进去，再从q poll出consume之前判断是否是null
        }
        if (pollNode.right != null) {
            que.offer(pollNode.right);
        }
    }
}
```
### S2
1. Ideas：
   - BFS 分层
2. Comments:
   - null
3. Code
```java
public List<List<Integer>> level(TreeNode root) {
	List<List<Integer>> result = new ArrayList<List<Integer>>();
	if (root == null) {
		return result;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();

    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size(); //一定要cache下来这个size，不能在for loop statement里动态调整size
        List<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();// offer, poll, peek
            list.add(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        result.add(list);
    }
    //Collections.reverse(result);  
    return result;
}
```
## Q2 L103 Binary Tree ZigZag Level Order Traversal
1. Description
   - 第一层，从左到右；第二层，从右向左；第三层，从左向右；...
2. Clarification
   - null
3. Follow up
   - Q2.1 能被三整除的行，从左向右打印
     - 使用level判断从左到右或是从右向左
   - Q2.2 what if print out null
### S1
1. Ideas：
   - tree level order traverse分层遍历
   - 加入一个boolean表示是从左向右还是从右向左
     - 从左向右，直接把当前的list加入
     - 从右向左，把当前的list reverse之后在加入result list
2. Comments:
   - null
### S2
1. Ideas：
   - 两个stack，一个stack是当前level正在遍历的element，一个stack放下一层的预备遍历的element
2. Comments:
   - 正向从左到右遍历正在用的stack，pop出来的element加到result中，同时先把left child加入下层的stack，再right child
   - 反向从右到左遍历正在用的stack，pop出来的element加到result中，同时先把right child加入下层的stack，再left child 
### S3
1. Ideas：
   - deque + level order traverse 分层遍历
2. Comments:
   - 从左向右则像level order traverse正常左边出右边进
   - 当要从右向左输出时，则是右边出左边进，同时是先把right child从左边进，然后再是left child 左边进
   - 这里奇数层从左向右，偶数层从右向左，如何在level order traverse各个level中不断切换？
     - boolean flag，只能表示两层
     - 0和1，flag = 0，flag = 1 - flag，只能表示两层
     - level直接看奇偶，可能level过深，所以level %= 2避免level++越界
3. Code
```java
public List<List<Integer>> level(TreeNode root) {
	List<List<Integer>> result = new ArrayList<List<Integer>>();
	if (root == null) {
		return result;
    }
    Deque<TreeNode> queue = new LinkedList<TreeNode>();

    queue.offerLast(root);
    boolean flag = false;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> list = new ArrayList<Integer>();
        for (int i = 0; i < size; i++) {
            if (flag == false) {
                TreeNode node = queue.pollFirst();// offer, poll, peek
                list.add(node.val);
                if (node.left != null) {
                    queue.offerLast(node.left);
                }
                if (node.right != null) {
                    queue.offerLast(node.right);
                }
            } else {
                TreeNode node = queue.pollLast();// offer, poll, peek
                list.add(node.val);
                if (node.right != null) {
                    queue.offerFirst(node.right);
                }
                if (node.left != null) {
                    queue.offerFirst(node.left);
                }
            }
        }
        flag = !flag; flag = 1 - flag;
        result.add(list);
    }   
    return result;
}
```
### S1 Q2.2
1. Ideas：
   - Tree level order traverse 不分层 print null
2. Comments:
   - null
3. Code
```java
public void levelOrderTraversal(TreeNode root) { 
	if (root == null) {
		return;
    }
    Queue<TreeNode> que = new LinkedList<>();
    que.offer(root);
    while (!que.isEmpty()) {
        TreeNode pollNode = que.poll();
        //?
        if (pollNode != null) {
            System.out.println(pollNode.value); //visit 
            que.offer(pollNode.left);
            que.offer(pollNode.right);
        } else {
            System.out.println("null");
        }
    }
}
```
## Q3 Validate a complete binary tree
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - level order traverse，只要遇到null后面不能出现非null的element，否则就不是complete binary tree
2. Comments:
   - 不分层level order traverse print null
   - 有null可以设个flag为true
3. Code
```java
public boolean isCompleteBT(TreeNode root) { 
	if (root == null) {
		return;
    }
    Queue<TreeNode> que = new LinkedList<>();
    boolean flag = false;
    que.offer(root);
    while (!que.isEmpty()) {
        TreeNode pollNode = que.poll();
        //?
        if (pollNode != null) {
            if (flag == true) return false;
            que.offer(pollNode.left);
            que.offer(pollNode.right);
        } else {
            flag = true;
        }
    }
    return true;
}
```
### S2
1. Ideas：
   - level order traverse，不分层
2. Comments:
   - 通过check parent的child是否是null来set flag
3. Code
```java
public boolean isCompleteBT(TreeNode root) { 
	if (root == null) {
		return;
    }
    Queue<TreeNode> que = new LinkedList<>();
    boolean flag = false;
    que.offer(root);
    while (!que.isEmpty()) {
        TreeNode pollNode = que.poll();

        if (pollNode.left != null) {
            if (flag == true) return false;
            que.offer(pollNode.left);
        } else {
            flag = true;
        }
        if (pollNode.right != null) {
            if (flag == true) return false;
            que.offer(pollNode.right);
        } else {
            flag = true;
        }
    }
}
```
### S3
1. Ideas：
   - 先level order traverse遍历非null，记录最后一个非null的index
   - 再level order traverse遍历包含null的最后一个非null的index
   - 两者应该一致，否则不是complete binary tree
2. Comments:
   - null
## Q4 Check whether a given graph is Bipartite or not (L785)
1. Description
   - http://www.geeksforgeeks.org/bipartite-graph/
   - 两个group之间有边，group内部无边，则称为可以bipartite
2. Clarification
   - 是不是联通的？
   - 是不是无向边？
   - input是不是cover所有各个非连通的graph？
   - 有没有cycle？
   - graph的表示方法？是GraphNode object还是用matrix？
3. Follow up
   - null
### S1
1. Ideas：
   - level order traverse涂color，neigh涂成第二个color，放进q，准备下次涂色，如果冲突，则return false
2. Comments:
   - 有cycle的话，涂过颜色的并第一次塞进queue之后，把visited field设为true，避免之后重复遍历，这里color可以代替visited的功能，涂了颜色并第一次塞进q就是visited过了
## Q5 Graph traversal
1. Description
   - 2D matrix的graph
2. Clarification
   - Graph各种clarify
3. Follow up
   - Q5.1 L286 Shortest Path in Simple Graph
   - Q5.2 Graph BFS vs Tree BFS
