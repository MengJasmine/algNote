# S2 Sorting Algorithm (v1)
## General Notes
1. 拿到各个数据结构的长度，arr.length，str.length(),list.size()，这里arr的length是field，其他是method
2. lc出现过的sorting：
   - bubble sort, __selection sort__, __mergeSort__, __quickSort__, Insertion sort, __count sort (bucket sort)__, heap sort, radix sort, __Topological Sorting__
3. sort本质就是大小比较，或者是priority的比较，也可能是customized的东西（例如基于frequency，或者先后出现次序）
4. call sort算法时，如果要customized的priority的比较关系，要传入comparator
5. bubble sort （很简单吗
6. Insertion sort （一个一个插入，见S1
7. selection sort
   - 双指针站肩问题
   - 不断地选择剩下一堆的最小值，加入到sort好的array中
   - 如何找剩下的最小值？
     - 直接无脑一个一个扫过去
     - 使用heap
     - 无重复的情况可以使用treeset和treemap
   - 具体过程：
     - 双指针i j，i初始化在i0，j初始化在i1，还有个minIndex记录当前最小值的index，初始为i，也就是0
     - j从i1开始，和i比较，
       - j小的话把minIndex设为j，j++
       - 不小则j++
     - j走完了，用minIndex那个值和i交换，i++，然后minIndex初始为i，j为i+1
     - 注意这里j设为i+1，出界问题
       - i走到最后一个数字（length-1），不用做了，所以i实际上是只要走到倒数第二个就行，也就是[0,nums.length - 2]，这样j(i+1)不会出界
   - 时间复杂度 = n-1 + n-2 + n-3 + ... + 2 + 1 = O(n^2)
     - 代码角度：for loop里for loop，n^2
   - 空间复杂度：没有用额外的数据结构，只用了pointer，所以是O(1)
   - selection sort的output可以一个int[]，也可以是void，都是作用于array本身
8. Merge sort
   - 一劈两半，问两边的sort结果，然后merge起来，局部有序到全局有序
   - 一劈两半，左右是个subarray，如何表示？直接用边界l和r可以表示，直接作用于原始array
   - divide and conquer思想，先call到base case，然后merge起来向上返值
   - dfs，call的时候进入系统栈，recursion的系统栈也可以算作空间复杂度（需要clarify），是logn（不断一劈两半，logn层，因为有且只有一条一路call到base case的路径/栈，最多logn，到底就开始pop了）
   - merge two sorted array
     - S1: create 新的array，两个pointer在两个sorted subarray的开头，谁小取谁放到新的array中
     - S2: inplace操作，其中一个subarray是放得下另一个的（这个要clarify！），放的下的那个subarray是这样的 1 2 3 4 * * * *，*是null
       - 不能正向做，会overwrite，所以发生这种overwrite情况可以尝试pointer从尾巴往前 （当然这个取决于*在尾巴还是头部，在头部也是从头开始才不会overwrite）
       - cur pointer从能放的下的array的尾部（1 2 3 4 * * * *）出发，谁大取谁，不会发生overwrite
     - S3: 注意在mergesort里，我们是用index标明两个要merge 的subarray，所以并不是两个独立的array，而是一个大array的左右两部分要merge起来 array = int[]{0 2 4 6 | 1 3 5 7}
       - deep copy 原来的array作为一个helper array，两个指针从劈成两个部分的开头走，谁小取谁放到原来的array中（这里两个指针一个在0，一个在1）
       - 这里while loop直到这两个指针有一个越界，如果是左边越界，那么右边多的就在原位，不用做postprocessing，如果右边越界，那么还要把deep copy中的左边指针剩下的copy到原始array的剩下部分
       - 时间复杂度：2n
   - stable的sort，注意重复状态也要保证次序，像是：1a 1b 1c变换后依旧要是1a 1b 1c，不能是1b 1a 1c
   - 时间复杂度：
     - divide，左右O(1)劈成两半，
       - 第一层 O(1=2^0) 劈成两半
       - 第二层 O(2=2^1) 两份劈成4半
       - 第三层 O(4=2^2) 4份劈成8半
       - ...
       - 第logn层，O(2^(logn-1)) = O(n/2)
       - 所有层加起来，1 + 2 + 4 + ... + n/2 = n - 1 = O(n)
     - conquer，同divide过程，只不过反过来，所以
       - 常见的错误时间复杂度算法
         - 所有层merge加起来，n/2 + n/4 + ... + 2 + 1 = n - 1
         - 做一次merge two是2n
         - 这里不能说：一共有n-1次merge，做一次merge two 是2n，所以总的时间复杂度是O(n^2)
         - 注意，这里每次merge 的n的size是变化的，也就是最底层是2个merge，最顶层才是n/2与n/2进行merge
       - 正确的说法是每次层merge花费n，一共logn层，所以一共花费nlogn
         - 这里每层不管你是两两merge，还是4个4个merge，你做merge two都要把所有元素扫一遍，越底层，你每次扫的少，但是有很多组要merge；越高层，你每次扫的多，但是merge的case少
     - 所以总的时间复杂度是O(n+nlogn)=O(nlogn)
   - 空间复杂度：
     - divide：O(1)
     - merge:
       - 系统栈算吗？
       - 如果每次merge到一个新的list向上return，那么每层有n size的list，一共logn层，所以一共占用nlogn的空间
         - 注意这里有java的garbage collection机制，也就是你merge完左半边，左半边创建的新的list已经被回收了，所以实际上空间占用率不会到nlogn
       - global使用一个deep copy原始array的一个helper array，使用这个占O(n)空间的helper array做所有的merge
9. Quick sort
    - 


```java
public int[] selectSort(int[] array) {
// public void selectSort(int[] array) {
	if (array == null || array.length <= 1) return array; // c.c.要check到1，毕竟1个也不用sort了

	int minIndex;
	for (int i = 0; i < array.length - 1; i++) {	// 不需要走到最后一位
		int minIndex = i; // 初始化为当前的i，所以j从i+1开始，尽量避免Integer.MAX_VALUE, MIN_VALUE，避免之后出现+1-1越界问题
		for (int j = i + 1; j < array.length; j++) { //站在i的肩膀上用j扫，从i+1开始
			if (array[j] < array[minIndex]) minIndex = j;
		}
		swap(array, i, minIndex);
        // 这里下面两种swap都可以，因为array操作都是在其本身，不cache出return的结果array也已经发生swap了
	}
	return array;
}

private void swap(int[] array, int i, int j) {
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
// return; 对于void可加可不加，出现在最后可以省略
}
// vs 上下两种不同写法
private int[] swap(int[] array, int i, int j) {
	int temp = array[i];
	array[i] = array[j];
	array[j] = temp;
	return array; // 不能省略
}

```
```java
private ArrayList<Integer> divideAndMerge(ArrayList<Integer> array, int left, int right) {
    ArrayList<Integer> result = new ArrayList<Integer>();
    if (left == right) {
        result.add(array.get(left));
        return result;
    }
    int mid = left + (right - left) / 2;

    ArrayList<Integer> leftResult = divideAndMerge(array, left, mid);
    // wall 只有上面return出来才会继续执行下面的语句
    ArrayList<Integer> rightResult = divideAndMerge(array, mid + 1, right);
    //
    return merge(leftResult, rightResult);
}

private void divideAndMerge( int[] nums, int start, int end, int[] helper){ // need a helper array

	if ( nums == null || nums.length <= 1 ) return; // left right to check!!!
		int n = end - start + 1;
		if( n <= 1) return;
		int mid = start + ( end - start ) / 2;
		divideAndMerge( nums, start, mid);
		divideAndMerge( nums, mid + 1, end);
		merge( nums, start, mid, end);
}
```
```java

```
## Q1 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null
3. Code
```java
class Solution {
    public int solution(int[] nums) {

   }
}
```


