# Binary Search
## General Notes
1. Binary search 不一定要sorted
2. Binary search 不一定是array，list可以，tree也可以，其他object也可以，只要有所谓的大和小可以进行比较就可以做binary search
3. 广义的binary search，只要整个序列具有单调性，就可以做binary search，像是00000001111111（一定要连续），狭义就是要sorted
4. 三种方法
5. Q1-Q8都是给了个array，也就是边界都是定的，left right已知，当边界未知时，例如Q9，当边界未知时，需要做preprocessing来确定边界
6. probe 算法，Q9

---------
## Q1 (L278) find bad version
1. Question description
   - 广义的binary search
   - Version/feature update
   - 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0
   -                      find here
2. Clarification (corner/edge case)
   - null
3. Follow up
   - 1 3 5 7 6 4 2 0 寻找波峰波谷
     - 就是找连续的0和连续的1的pattern（上升下降，前后差值），
     - 前后差值注意i-1和i，注意i-1出界问题
   - 5 6 7 8 1 2 3 4 rotated sorted array, 寻找最小值
     - 同样寻找连续的0和连续的1的pattern
4. Others
   - null
### S1
1. Ideas：
   - two pointer 在左右，一劈两半，做binary search
2. Comments:
   - while loop进入条件是l和r左右相邻
3. Code

```java
class Solution {
    public int solution(int[] nums) {

    }
}
```
----------
## Q2 (L374) Guess Number
1. Question description
   - 1到100猜数字
2. Clarification (corner/edge case)
   - null
3. Follow up
   - null
4. Others
   - null
### S1
1. Ideas：
   - 最基础的binary search题目
2. Comments:
   - null
3. Code

```java
class Solution {
    public int solution(int[] nums) {

    }
}
```
----------
## Q3 Classical Binary search Template
1. Question description
   - Given sorted array, find target, if exist return index otherwise return -1
2. Clarification (corner/edge case)
   - 注意while loop跳出条件
3. Follow up
   - 这里是有限size，可以follow up的是stream data
   - 在binary search tree中找target
     - binary search取左半边，相当于tree里走left subtree
4. Others
   - two pointer往中间走都会面临左右相邻，相等或者越过的三种情况
### S1
1. Ideas：
   - while loop 跳出时左右越过
2. Comments:
   - 跳出时不用post processing，因为已经越过了
   - 注意left = mid + 1和right = mid - 1，左右越过不做postprocessing一定要+1，-1
   - 为啥要+1，-1？因为我们是要找target，不相等一定要缩小边界范围，才能越过跳出while loop，不然无法跳出while loop
   - S1适合直接找target值
3. Code
```java
class Solution {
   public int binarySearch(int[] nums, int[] target) {
      //c.c.
      if (nums == null || nums.length == 0) return -1;

      int left = 0;
      int right = nums.length - 1;
      int mid = 0;
      while (left <= right) {
         mid = left + (right - left) / 2;
         if (nums[mid] == target) return mid;
         if (nums[mid] < target) left = mid + 1;
         if (nums[mid] > target) right = mid - 1;
      }
      return -1;
   }
}
```
### S2
1. Ideas：
   - while loop 跳出时左右相等
2. Comments:
   - 跳出时相等，最后那个相等的值没有check，所以还是要postprocessing
3. Code
```java
class Solution {
   public int binarySearch(int[] nums, int[] target) {
      //c.c.
      if (nums == null || nums.length == 0) return -1;

   }
}
```
### S3
1. Ideas：
   - while loop 跳出时左右相邻
2. Comments:
   - 需要post processing
   - S3适合找分界线，因为最后跳出条件是左右相邻，相当于夹着分界线
   - 因为是找分界线，所以不能left = mid + 1和right = mid - 1，因为我们不是找target，是找分界线，就算当前不是target，我们不能+1-1导致越过分界线，最后就夹不住分界线了
3. Code
```java
class Solution {
   public int binarySearch(int[] nums, int[] target) {
      //c.c.
      if (nums == null || nums.length == 0) return -1;

      int left = 0;
      int right = nums.length - 1;
      int mid = 0;
      while (left + 1 < right) {
         mid = left + (right - left) / 2;
         if (nums[mid] < target) left = mid;
         if (nums[mid] > target) right = mid;
      }
      if (nums[left] == target) return left;
      if (nums[right] == target) return right;
      return -1;
   }
}
```
-------------
## Q4 Start & Last position of Target
1. Question description
   - 1 2 3 3 3 3 4 5 6 找第一个target 3，找最后一个3的index
2. Clarification (corner/edge case)
   - null
3. Follow up
   - Q4.1 L34 search for a range
     - 1 2 3 3 3 3 4 5 6 找2到4的range，或者找所有的3
     - 亦或者是，找(1.9, 3.1)，return index 1 和 5
     - 一般推荐return index而不是新建一个array，费空间
     - [1,9, 3.1] vs. (1.9, 3.1) 注意寻找range时给的范围区间的开闭情况
     - 如果是找[1,9, 3.1]，就是找等于1.9或者是比1.9大的最小的（嗯，这个题做过！Q6！），3.1同理
   - Q4.2 First position of target
     - 要找的是比3小的最近那个和第一个3的分界线，所以用binary search的找分界线方法做
   - Q4.3 Last position of target
4. Others
   - null
### Q4.2 S1
1. Ideas：
   - binary search
   - 找分界线的S3
2. Comments:
   - 注意postprocessing，分界线不一定夹在中间！比如 3 3 3 3 4 5 6找第一个3，根本夹不住！所以这里一定要先check left，left是3就是了，再check right，right是3就是了，两者都不是就没3
3. Code

```java
class Solution {
   public int binarySearch(int[] nums, int target) {
      // Corner case
      if (nums == null || nums.length == 0) return -1;

      int left = 0, right = nums.length - 1, int mid = 0;	
      while (left + 1 < right) {
         mid = left + (right - left) / 2;
         if (nums[mid] < target) left = mid;
         // else if (nums[mid] >= target) right = mid;
         else right = mid;
      }
      if (nums[left] == target) return left;
      if (nums[right] == target) return right;
      return -1;
   }
}
```
### Q4.3 S1
1. Ideas：
   - binary search
   - 找分界线的S3
2. Comments:
   - 和Q4.2，类似，也是要注意edge case
   - 注意postprocessing，分界线不一定夹在中间！比如 1 2 3 3 3 3找最后一个3，根本夹不住！所以这里一定要先check right，right是3就是了，再check left，left是3就是了，两者都不是就没3
3. Code

```java
class Solution {
   public int binarySearch(int[] nums, int target) {
      // Corner case
      if (nums == null || nums.length == 0) return -1;

      int left = 0, right = nums.length - 1, int mid = 0;	
      while (left + 1 < right) {
         mid = left + (right - left) / 2;
         if (nums[mid] <= target) left = mid;
         // else if (nums[mid] > target) right = mid;
         else right = mid;
      }
      // first check right!
      if (nums[right] == target) return right;
      if (nums[left] == target) return left;
      return -1;
   }
}
```
### Q4.1 S1
1. Ideas：
   - 1 2 2 3 3 3 3 4 5 6 找所有的3
   - 之前分解动作会了，这里做两次binary search找第一个3和最后一个3
2. Comments:
   - null
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
### Q4.1 S2
1. Ideas：
   - 1 2 2 3 3 3 3 4 5 6 找所有的3
   - 先找到第一个3，然后新的pointer站在这个3的肩上往右找所有的3（找最后一个3同理往左找所有的3）
2. Comments:
   - S1 vs S2？
     - S1的时间复杂度：logn + logn = O(logn)
     - S2的时间复杂度：logn + n = O(n)
     - It depends，如果S2的n很小（有限定条件），n则是k，S2好
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
## Q5 Closest Position of Target
1. Question description
   - 找target，找到则返回，没有返回离target最近的值
2. Clarification (corner/edge case)
   - 何为closest？比他小比他大？如果两边距离一样，两个值怎么办？
   - 找到直接return
   - 只要有数字，不会找不着，不会return -1
3. Follow up
   - Q5.1 k closest position of target
     - 问：k如果大于array.length，那么全部array都是。k是否是valid也需要clarify
   - 如果不是array，放到binary tree里，寻找k closest node？
     - 这里没法直接通过pointer--/++拿到紧邻的前一个或者后一个
### S1
1. Ideas：
   - binary search S3，要找分界线，夹住target然后做postprocessing
2. Comments:
   - 比较左右距离，无脑用Math.abs __预防性编程 --> 预防可预知的问题，使得程序robust__
   - 还是有可能夹不在中间，edge case，比如 1 2 3 4 5 6 找0.1（或者6.1），所以上面的预防性编程可以解决，因为无脑比较l和r的距离
3. Code
```java
class Solution() {
   public int binarySearch(int[] nums, int target) {
      // Corner case
      if (nums == null || nums.length == 0) return -1;

      int left = 0, right = nums.length - 1, int mid = 0;	
      while (left + 1 < right) {
         mid = left + (right - left) / 2;
         if (nums[mid] < target) left = mid;
         else if (nums[mid] > target) right = mid;
         else return mid;
      }
      // return a ? b : c;
      return Math.abs(array[left] - target) < Math.abs(array[right] - target) ? left : right; // defensive/preventive drive/program Math.abs // 无脑
   }
}
```
### Q5.1 S1
1. Ideas：
   - 同Q5，先找到距离最近的，然后l和r摆在这个最近的左右两边，两边比较abs距离，小的加到result里，然后相应的pointer++（或者--）
2. Comments:
   - 注意pointer++或者--出界问题
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
----------
## Q6 Largest smaller Position of Target
1. Question description
   - 寻找比target小的最大的
   - 1 2 3 3 3 3 3 4 5 6 target = 3，则return 2
2. Clarification (corner/edge case)
   - 和寻找first of position很像
   - 和closest也很像，相等的时候不算，从比target小的方向closest
3. Follow up
   - null
### S1
1. Ideas：
   - binary search，类似寻找first position of target
   - 找到分界线也是用postprocessing去判断
2. Comments:
   - 同理注意夹不到的情况！
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
----------
## Q7 Smallest larger Position of Target
1. Question description
   - 类似Q6
2. Clarification (corner/edge case)
   - null
3. Follow up
   - Q7.1 L35 Search Insert Position
     - 1 2 3 3 3 3 4 5 6 插入4.5 --> 1 2 3 3 3 3 4 4.5 5 6
     - 连续不断地插入，从0开始进行sort --> insertion sort
     - Insertion sort 时间复杂度？
       - n个数
       - 用binary search的logn时间找到插入位置
       - 所有大的数要往后shift才能插入，这个要花费O(n-k)，也就是O(n)
       - 所以是n * (logn + n)，最终是O(n^2)
   - 
### S1
1. Ideas：
   - binary search 找last of position，用postprocessing去处理
2. Comments:
   - 同理注意夹不到的情况
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
----------
## Q8 (L162) Find Peak/Valley Element
1. Question description
   - 1 3 5 7 9 8 6 4 2 寻找波峰或者波谷
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - binary search，就是找连续的0和连续的1的分界线
   - 0就是升序，1就是降序
   - 升降序是前后差值
2. Comments:
   - 一旦有前后做差值 num[ i ]-num[i - 1]，就一定有edge case！i - 1是否出界
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```
----------
## Q9 Unknown size Position of Target --> streamming
1. Question description
   - xxxxxxxxxxxxxxxxxxxxxxxxxxxxTxxxxxxxxxnnnnnnnnnnnnnnnnnnn
   - 这个也是要sorted
   - 寻找target T，注意用get(index)访问到后面n就会返回null
2. Clarification
   - Unknown size的解释
     - streamming flow，数据一直来，无穷无尽
     - 给的input sorted array非常大，内存放不下，找不到边界，也就是Q9.1
   - 新的api，只有myArray.get(index)，有返回值，没有的话（太后面访问不到，亦或是不在内存里）返回null，没什么array.length啥的
   - probing算法
     - 发生hash collision时，从发生的位置往后线性一个一个找valid的位置
     - check website up or down，今天去看看，明天去看看，4天以后再看看，8，16，32 ...
     - 多线程网络传输：假设一个网卡只能处理一种情况，多个线程请求网络传输，当网卡不valid，自己delay 2秒，2秒后再check，还不行，delay 4秒，再不行，delay 8秒，以此类推
     - 当然也可以不用线性，两倍四倍都行，it depends
3. Follow up
   - Q9.1 search in a very big sorted Array
   - Q9.2 Drop egg
     - 题目描述
       - 有一座楼，高度可以已知可以未知
       - 有若干鸡蛋，可以有限个，也可以无限个
       - 鸡蛋强度固定，即：x层以上丢一定碎，以下丢一定不碎
       - 寻找x层
     - 如果鸡蛋数量有限
       - 如果只有1个，只能一个一个走
       - 如果是k个鸡蛋，楼层无限，先probing算法找边界，知道只剩一个鸡蛋，然后一层一层丢
     - 如果鸡蛋数量无限
       - 如果楼层有限，取一半丢
       - 如果楼层无限，用probing算法找边界，然后做binary search
   - Q9.3 Bond get收益率(price)
     - 应用题，具有单调性，有最大最小值（boundary，left right)，可以用binary search
### S1
1. Ideas：
   - binary search
   - 通过probing算法确定start和end边界来夹住target
     - 开始     s____e____________T
     - 发现不在  _____s__________e_T，注意这里s也能移到之前的e
     - 不断找
     - 直到  _______s____T_____e
     - 这时候e可能是比T大，或者是null    
   - 有了边界就可以用binary search找target，用找target的left <= right的方法
2. Comments:
   - 初始化s和e时，s出生在0，e出生在1，这时候要注意没有1的corner case
   - 这里getIndex出来的是Integer，如果和int target进行比较会有问题
   - 注意新的e可能是T，也可能是null，要加check是否是null再进行与target的大小比较，null和数字没法比较大小！
   - 因为是很大的array，output可能用int表示不下，考虑TODO long
   - 这里*=，注意 a += b 是 a = a + b，尤其是string有顺序区别要注意！
   - 找到边界做binary search时，注意找mid时候，mid也还是可能是null，可能因为之前e一步迈太大步囊括了好多个null
3. Code
```java
class Solution {
   public int unknownSizePosition(MyArray myArray, int t){//TODO: long
      // corner case check length <= 1

      int start = 0;
      int end = 1;
      
      while(myArray.get(end) != null && myArray.get(end) < target) {
         start = end;
         end *= 2;
      }
      
      while (start <= end) {
         int mid = start + (end - start) / 2;
         if (myArray.get(mid) != null && myArray.get(mid) == t) return mid;
         else if (myArray.get(mid) != null && myArray.get(mid) < t) start = mid + 1;
         else end = mid - 1; // myArray.get(mid) == null || myArray.get(mid) > t
      }

      return -1;
   }
}
```
----------
## Q10 Matrix Position of Target
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q10.1 L74 Search a 2D Matrix
   - Q10.2 L240 Search a 2D Matrix II Quadrate Search
### S1
1. Ideas：
   - null
2. Comments:
   - null
3. Code
```java
class Solution {
   public int solution(int[] nums) {

   }
}
```