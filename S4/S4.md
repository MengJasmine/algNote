## Queue & Stack
1. 实现一个以Double Linked list为基础的list class
   - null <-> 1 2 3 4 <-> null
   - 首先先要想到要有组成linked list的ListNode
   - 一般创建一个list，```List<Integer> list = new LinkedList<>()```，这里<Integer>数据声明的是ListNode里的value的数据类型，而不是ListNode本身的数据类型，因为ListNode本身类型就是ListNode，是用来组成Linked list的基础。通常用generic泛型来传入任何类型
   - Constructor不仅仅是赋予各个field的初值，同时还要在内存中分配空间和allocate所需的reference以及其他系统的任务，因此如果要在overloading的constructor中调用之前的constructor，需要用keyword __this__，而不是相同的名字，如果是调用相同class名字的function，那只是执行了赋初值的作用，而没有allocate系统地址和空间。这里this特指本class，因为class的name和constructor name相同，这里用this表示调用本class以区别于调用constructor。
   - overloading issue：overload只会发生于input类型不一致，而不会因为output类型不同
     - overload出现在编译时，因为output只有在运行时才能知道类型，所以不会发生overload
     - given:
         - public int myMethod(int a); //会产生overload
         - public int myMethod(String a); //会产生overload
         - public int myMethod(int a, String b); //会产生overload
         - public String myMethod(int c); // 不会产生overload
   - 实现一个list，不管是用linked list或者是array来实现，外部使用的时候只关心list本身的功能，而不关心list到底是怎么实现的，也就是像是ListNode或者array这种都应该是private，透明，用户不可见的
   - 当实现double linked list，由于存在head和tail双向标识，add或者delete head要根据只有一个node和多个node两种不同情况进行处理。两种处理方法：head，tail无脑dummy node，永远有的，第二种就是分别进行判断（类似之前的preprocessing）
```java
class ListNode<T> {//TODO: generic
    // fields
    T value;
    ListNode prev;
    ListNode next;

    // methods
    ListNode(T val) {
        value = val;
        next = null; // initialize null
        prev = null;
    }

    ListNode() { // constructor overloading
        this(0); // reuse之前的constructor，但是这里不能写ListNode(0)，详见上
    }
}
public class LinkedList {
    //field
    head;
    tail;

    //method
    LinkedList() {

    }
    getVal(int index) {

    }
    addHead();
    addTail();
}
```
1. 
## Q1 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null
3. Code
```java
class Solution {
    public int solution(int[] nums) {
        
    }
}
```


