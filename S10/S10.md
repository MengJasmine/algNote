## S10 Array & String
1. 任意长度数字加和，比较好的是使用linked list表示任意长度数字，dynamic
   - 可正可负可为零，注意clarify空的，两者位数之间的差异，还有最高位之前有零的情况
2. String内部实现使用 char array，string中的char是ascii 码，ascii码的array
3. Array，two pointer
   - slow fast同向，如果slow会越过fast，产生overwrite，可以尝试从右边往左边走（merge sort中merge的过程）
   - left right相向
     - 左右相邻，左右相等，左右越过
   - 中间往两边
     - 中间位置取决于size的奇偶
4. String问题如何较好的CRUD操作
   - ```s.toCharArray()```直接转换成char Array做
   - 如果要从char array中的一部分转换成string，可以```new String(charArray, 0, s)```，这里0是起始index，s是这个substring的size，也就是终止index+1！这里是左闭右开区间
   - 同时char array转换成string可以调用valueOf，```String str = String.valueOf(charArray);```，只不过这个不能通过index取substring。不过再转换成string，可以再call substring，只不过时间复杂度较高。
   - 如果这个string是word separate by space，可以```s.split(" ")```这里split是exactly一个空格，如果是要满足一个或者多个，需要regex
   - 当string size频繁变化，可以使用StringBuilder，
     - append是O(1)，但是insert(i)是O(n)
     - sb.toString()转换为String
     - sb.deleteCharAt(i)删掉index为i的char，backtracing时更好的选择是sb.setLength(l)把sb固定设为size l，setLength()更好的原因是之前append可能的size不固定的string、word，setLength直接set在append之前cache下来的原来的length可以处理这种情况
     - sb.charAt(i)读取index i的char是个啥
   - string1 + string2
     - string是immutable，所以加号都会new一个新的string，慎用
   - string本身有个s.charAt(i)，只读index i的char是个啥，不能写，如果只有读的操作，可以不用上面转换的过程
   - string的s.subString()是new了一个新的string，创建的时间复杂度也是O(n)。这个要clarify是否可以使用substring。如果不让使用substring，可以使用start和end两个index来标识所操作的substring的范围，这里范围是[start, end)，同样也是左闭右开区间。如果只是用一个parameter，默认是startIndex，也就是取到的substring是当前index到最后所有的substring
5. String的各种topic
   - Reverse
   - Encode/Decode/Match
   - Deduplicate
   - Remove / replace
   - Substring
   - Permutation
   - Anagram / Palindrome / isomorphic
   - DP, Longest, Largest …
   - DFS
## Q1 Remove chars from String (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - slow fast指针
   - fast指针扫原始string，遇到要删除的直接跳过
   - slow用于创建和保留fast遇到的不要删除的
2. Comments:
   - slow所创建的这个一直在尾部加char，同时最后要求string输出，所以可以使用StringBuilder
   - 因为fast永远站在slow的前面或者重合，slow永远不会越过fast，所以可以实现inplace操作，不会有overwrite的发生，如果不是remove，是replace by 2，即特定char找到把它一个变2个，这样slow可能会越过fast，这样把fast还没check到的char给overwrite了
   - 上面这个inplace操作过程：
     - 判断cc
     - s和f起始在index 0
     - 然后check f
       - 如果是要删的，f++
       - 如果不是要删的，set s为当前f的值，s++，f++
       - 做到f == array.length时，这时f出界，result出现
   - 这个操作中:
     - [0, s) 是solution so far
     - [s, f) don't care
     - [f, array.length - 1] to do
   - 如果要从char array中的一部分转换成string，可以```new String(charArray, 0, s)```，这里0是起始index，s是这个substring的size，也就是终止index+1！
   - “s"是String，'s'是char
   - 类似quick sort partition swap方法不行，出来的结果不是stable的
3. Code
```java
public String removeChar(String s) {
	// corner case
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
    for (int fast = 0; fast < chars.length; fast++) {
        if (chars[fast] != ‘o’ && chars[fast] != ‘f’) chars[slow++] = chars[fast];
    } 
    return new String(chars, 0, slow);
}
```
## Q2 Remove leading/trailing/and duplicate space with one remaining. Trim() (L???)
1. Description
   - 实现trim()，string中最前最后space删除，中间word之间的space留一个
   - auto script格式规范化code，linter
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - 类似Q1的S1，使用slow fast指针inplace操作，这里注意处理space的问题
2. Comments:
   - 连续紧邻的duplicates
     - 保留重复的第一个？ --> 当```array[i] == array[i-1]```删除array[i]
     - 保留重复的最后一个 --> 当```array[i] == array[i+1]```删除array[i]
   - 这里保留word之间的第一个space。另一个解释保留word之间最后一个space
   - 注意i-1越界问题，当i等于0同时还是space时，这些space都要删去
   - 队尾的space要在postprocessing中处理，由于除了一开始的一波space，是默认保留第一个space，所以如果原始string末尾有space，这里出来的slow指针也会加一个space，同时也会存在原始string末尾没有space的情况。综上，要postprocessing确认下slow - 1是不是space。而这里slow - 1也可能越界，发生于input全是space的情况，这是一个corner case要提前check。
   - check slow - 1是不是space也可以等效checkfast跑完，fast - 1是不是space，其实就是check原始string中尾部是否有space
   - 这里如果是保留word之间最后那个space，就要postprocessing string之前是否有space
3. Code
保留word之间第一个space
```java
public String removeSpaces(String s) {
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
	for (int fast = 0; fast < chars.length; fast++){
		    //取非 chars[fast] != ‘ ’ || (fast != 0 && chars[fast - 1] != ‘ ’)
		if (!(chars[fast] == ‘ ’ && (fast == 0 || chars[fast - 1] == ‘ ’))) {
			chars[slow++] = chars[fast];
        }
}
	if (slow == 0) return “”;
return chars[slow - 1] == ‘ ’ ? 
		new String(chars, 0, slow - 1) : new String(chars, 0, slow);
}
```
保留word之间最后一个space
```java
public String removeSpaces(String s) {
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
	for (int fast = 0; fast < chars.length; fast++) {
		if (!(chars[fast] == ‘ ’ && (fast == chars.length - 1 || char[fast + 1] == ‘ ’))) {
			chars[slow++] = chars[fast];
        }	
    }
	
    if (slow == 0) return “”; // 下面那个slow - 1，所以这里要check slow == 0
    return chars[0] == ‘ ’ ? 
		new String(chars, 1, slow - 1) : new String(chars, 0, slow);
}
```
## Q3 Remove Duplicates from Sorted Array (L???)
1. Description
   - sorted，adjacent，去重留k个
2. Clarification
   - sorted，或者必须是adjacent，也就是duplicate必须连续出现
3. Follow up
   - Q3.1 Remove duplicated adjacent letters / sorted letters with one left / two left / no one left
   - Q3.2 For no one left, remove again repeatedly → stack
   - Q3.3 Sorted letters Remove duplicated letters with one left / two left / no one left
### S1
1. Ideas：
   - 依旧slow fast指针
2. Comments:
   - 这里只适用于sorted，或者adjacent，以及去重留1个，或者1个以上的情况
   - 如果留k个，k > 0，具体过程：
     - 先判断cc，如果不足k个则需要clarify，全部保留
     - slow fast初始在index k，也就是前面有k个无脑保留
     - 然后check array[fast] == array[slow - k]
     - 由于题目是adjacent，所以如果相等，slow - k到fast全都是相等的，也就是一定大于k，fast++，slow不变，因为slow此时也是等于slow - k，这时正好这个相同的取满k个
     - 当不相等时，array[slow] = array[fast]，然后slow++，fast++
     - fast走完，[0, slow)是答案；[slow, fast)已经check的，可以overwrite的；[fast, array.length - 1]是要check的
3. Code
```java
public String removeSpace(String s, int k) {
	if (s == null || s.length() <= k) {
	return s;
    }
    char[] array = s.toCharArray();
    int slow = k;

    for (int fast = k; fast < s.length(); fast++) {
        if (array[fast] == array[slow - k]) {
            continue;
        }
        else array[slow++] = array[fast];
    }
    return new String(array, 0, slow);
}

```
### S2
1. Ideas：
   - slow fast指针，只不过不同的区间定义
2. Comments:
   - [0, s] solution so far
   - (s, f) explored and i don't care / will be update or assign
   - [f, length - 1] unknown to explore
3. Code
```java
public String removeSpace_K_left_S2(String str, int k) {
	if (str == null || str.length() <= k)
		return str;
	chars[] array = str.toCharArray();
	int slow = k - 1, len = array.length();	
	for (int fast = k; fast < len; fast++) { 
        // k ＝ 1 yes, k >= 2 NO
		if (array[fast] != array[slow + 1 - k])	{
			array[++slow] = array[fast];
        }	
	}
	return new String(array, 0, slow + 1);
}
```
## Q4  L344 Reverse String → Swap (L344)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - swap, while loop
2. Comments:
   - null
3. Code
```java
public String reverseString(String s) {
	if(s == null || s.length() <= 1) return s;
	char[] array = s.toCharArray();
	int i = 0;
	int j = array.length - 1;
	while (i < j) {
		swap(array,i++,j--);
    }
    return new String(array);
}
```
### S2
1. Ideas：
   - swap, recursion
2. Comments:
   - null
3. Code
```java
public String reverse (String s){
	if ( s == null ||  s.length() < 2 ) return s;
	char[] array = s.toCharArray();
    array = help(array, 0, s.length() - 1);
    return new String(array, 0, s.length());	
}
// 先swap 后call
private char[] help( char[] array, int start, int end){ // void可以不return
	int n = end - start + 1;
	if ( start >= end) return array[start]; // wrong
	swap(array,start,end);
	return help(array, ++start, --end);

//先call 后swap
public void helper(char[] chars, int left, int right) {
	if (left >= right) return;
	helper(chars, left + 1, right - 1); 
	// wall
	swap(chars, left, right);
	// return

｝
```
## Q5 Reverse Words in a String (L151)
1. Description
   - you get offer --> offer get you
2. Clarification
   - input type?
   - space的处理情况，两个space要不要trim？前后space要不要保留？
3. Follow up
   - Q2.1 L186
   - input包含符号，即：let's go to 'New York' --> 'New York' to go Let's
     - S2可以handle，碰到引号则无脑要check到下一个引号，然后再reverse，不管中间的space
### S1
1. Ideas：
   - split to word array, reverse this word array
### S2
1. Ideas：
   - reverse globally
   - reverse words separately again to the normal order
2. Comments:
   - 注意如何用slow和fast确定一个又一个的word
   - 也可以先reverse每一个word，再全局reverse
## Q6 String Rotate / Shift (L???)
1. Description
   - http://www.lintcode.com/en/problem/rotate-string/
   - 以index k为pivot，rotate这个string。或者向右shift k位
   - e.g. input string = abcdefg, k = 3；return: efgabcd 
2. Clarification
3. Follow up
   - 如果input是single linked list？
     - 直接找到要断开的前后两个node，接上head就行
   - 如果input是queue？
     - 只能把n - k个都poll出来，这里k如果大于size的话，要k%size取个余，然后再把poll出来的offer进queue里
### S1
1. Ideas：
   - 先reverse globally
   - 然后把pivot前面和后面再分别reverse
## Q7 L44 L10 space in url to %20 http://amazon.com?keyword=iphone%205
1. Description
   - 在url中把 %20 replace成space
2. Clarification
   - null
3. Follow up
   - Q7.1 replace words
     - yougetoffer --> youXXXoffer
     - get --> put
     - get --> pu
     - get --> access
     - 使用slow fast可以处理replace size一样和较短的，当replace较长（access这里）会出问题，inplace操作时slow会越过fast
     - 当要处理较长的replace同时要求inplace操作，可以先扫一遍整个string，count一下有多少个target需要被替换，replace后的word比target长的差值再乘以这个count，就会知道整个string总的会变长多少。然后再整个string尾部添加这么多的空格来实现offset，slow从整个添加完space的尾部，fast则从原始input string的尾部，这样可以保证slow永远不会越过fast，而且不会额外浪费空间
     - 这里类似于merge two sorted array的inplace操作，也是先给个offset，然后从右向左做
   - pattern match
     - i * n <-match-> internationalization <-match->
     - 要全扫完才能确定i开头，n结尾的match
     - 多语言支持：http request中含有包含语言和浏览器信息。html中placeholder，根据不同语言到不同folder（us，cn，...）去找对应的value
## Q8 Encoding: aaabbbbccdeee → a34b4c2d1e3	abcdef (L???)
1. Description
   - null
2. Clarification
   - sorted？adjacent？
3. Follow up
   - Q8.1 Decoding: a1b4c2d1e34 → aaabbbbccdeee
     - 同理，offset一定的space从右向左slow fast
     - 这里decode在preprocessing确定要offset多少个时，从左向右读每个char要几个时，要读到下一个char出现为止，另一种思路是可以从右向左读这些count，可以使用stack，比如example里，把4 3push到stack里，然后发现是e，不是数字，就把stack中的数pop出来 3 4，组成34
   - Q8.2 Matching: i18n -- internaltionalization]=
   - Q8.3 L91 Decode Way
   - *Q8.4 L38 Count and Say
   - Q8.5 L8 String to Integer 
   - **Q8.6 L273 Integer to String (读法） 111111
     - 如何读？
### S1
1. Ideas：
   - offset一定的space从右向左slow fast指针
2. Comments:
   - 整体变短，但是局部有增长的趋势，即只有一个的时候encode后变成x1，所以要从右向左做，先count有多少个一个的，offset这么多，然后从右向左做
## Q9 implement strStr() → indexOf() (L28)
1. Description
   - 问短string是不是长string的substring，indexOf()可以返回如果是的话，长string中match短string的第一个index
2. Clarification
   - 长str，短str？谁长谁短？
3. Follow up
   - 短list是长list的sublist
     - clarify是ArrayList还是LinkedList
     - ArrayList基本类似string
     - LinkedList，input是ListNode
       - 判断谁长谁短也要遍历两个整个的linked list
       - 注意这里for loop换成while loop来遍历linked list
       - 同时，内层while比较长和短的linked list时，不能动站肩的cur ListNode，也就是要先把站肩的那个ListNode cache下来，走内层时，动的是cache下来的那个copy，cacheNode = cacheNode.next
       - match成功的条件是短的LinkedList遍历到null
   - 小tree是大tree的subtree
     - for every possible node in big tree, do the same tree comparison with the small tree
### S1
1. Ideas：
   - brutal force, 直接n2取得input的所有substring，然后比较
### S1
1. Ideas：
   - two pointer站肩
   - ![fig10-1](Fig10-1.png)
2. Comments:
   - 要扫n - m + 1
   - 被站肩的index i不能动，短str的j和长str的i+j进行比较
   - 如果不match，for loop j来比较长str的i+j和短str的j就会break；如果match，这个for loop就会走完
   - 谁长谁短可以preprocessing，再call一遍
   - 时间复杂度：O(n * m)
3. Code
```java
public int strStr(String s1, String s2) {
    // int len1 = s1.length(); // wrong 要cache各个str的length也是在cc之后
	if (s1 == null || s1.length() == 0 || s2 == null || s2.length() == 0) return -1;

	if (s2.length() > s1.length()) return strStr(s2, s1); //这里不能写等于，就会stack overflow
	
	for (int i = 0; i < s1.length() - s2.length() + 1; i++) {
		int j; // 这里j得声明在for loop外面，这样才能在外面access到j的val，来判断for loop是否走完
		for (j = 0; j < s2.length(); j++) {
			if (s1.charAt(i + j) != s2.charAt(j)) break;
            // if (j == s2.length() - 1) return i; // 每次check，不好
		}
		if (j == s2.length()) return i; //只check一次，可以
	}
	return -1;
}
```
### S2
1. Ideas：
   - Robin karb sliding window
2. Comments:
   - hash，每次sliding window 平移，把之前的val的hash减掉，把新的加进来的val的hash加上，和短str的hash相比
   - 时间复杂度：O(n+m)，每次sliding O(1)来计算hash，扫n - m + 1个，同时计算m size短的hash
   - 有个问题，短str很长，hash出来的int很大，越界；或者hash function的设计，出现hash collision。一个解决方案是不要做一次性hash，可以把很长的这个短str，分成好几部分，对每部分分别hash，组成一个hash后的list，这个list就可以比较而不会发生越界或者hash collision了
### S3
1. Ideas：
   - KMP
2. Comments:
   - null
## Q10 String Permutations with Duplicate (L???)
1. Description
   - null
2. Clarification
   - adjacent?
3. Follow up
   - Q10.1 String Permutations without Duplicate
     - swap方式dfs做
### S1
1. Ideas：
   - 参考without duplicates，最后使用hashset查重
### S2
1. Ideas：
   - 参考without duplicates，提前pruning
   - swap只swap重复的第一个
2. Comments:
   - swap重复的第一个，下层一定能包含swap第二个的情况，不会遗漏，同时避免重复
   - hashset确定要交换的第一个；如果是adjacent，也不可以使用i和i-1比较，因为这里使用的是swap方法，swap之后就不adjacent，下层i和i-1判断就有问题了
   - 这里就是同层跳过一些不进的case，最好使用hashset来查重，能add就走，不能add进去就跳过
3. Code
```java
public List<List<Integer>> permuteUnique(int[] nums) {
	List<Integer> result = new ArrayList<Integer>();
	if (s == null || s.length() == 0) {
		return result;
    }
    char[] array = s.toCharArray();
    permutation(array, result, 0);
    return result;
}

private void permutation(int[] array, List<Integer> result, int index) {
	if (index == array.length) {
		result.add(new String(array, 0, array.length));
		return;
    }
	Set<Character> set = new HashSet<>(); // → boolean[26] → Bit Integer → ListNode + HashMap
    for (int i = index; i < array.length; i++) {
        if (set.add(array[i]) { // compare array[i] vs array[i-1] // 有问题,需要加visited 并且得是另一类搜索树
            swap(array, index, i);
            permutation(array, result, index + 1);
            swap(array, index, i);
        }
	}
}
```
## Q11 Valid Anagram (L???)
1. Description
   - Anagram? 两个str all possible取值的可能性一样，而且每个char的个数一样
2. Clarification
   - null
3. Follow up
   - Q11.1 Valid Palindrome
   - Q11.2 L9 Palindrome Number
   - Q11.3 isomorphic String
   - Q11.4 Group Anagram
### S1
1. Ideas：
   - 两个hashmap分别count这两个str
2. Comments:
   - 两个hashmap的比较
### S2
1. Ideas：
   - 一个hashmap
2. Comments:
   - 先判断两个str的length是否相等！非常重要！因为要排除hashmap里放的那个str fully cover str2的情况！
   - 先用hashmap统计str1的各个char的个数
   - 然后开始遍历str2，每个char先看看hashmap contain不？contain，则其value--，然后把value减1的值put回去
   - 如果不contain，或者value减得小于0，则不是anagram



