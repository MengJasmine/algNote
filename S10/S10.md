## S10 Array & String
1. 任意长度数字加和，比较好的是使用linked list表示任意长度数字，dynamic
   - 可正可负可为零，注意clarify空的，两者位数之间的差异，还有最高位之前有零的情况
2. String内部实现使用 char array，string中的char是ascii 码，ascii码的array
3. Array，two pointer
   - slow fast同向，如果slow会越过fast，产生overwrite，可以尝试从右边往左边走（merge sort中merge的过程）
   - left right相向
     - 左右相邻，左右相等，左右越过
   - 中间往两边
     - 中间位置取决于size的奇偶
4. String问题如何较好的CRUD操作
   - ```s.toCharArray()```直接转换成char Array做
   - 如果要从char array中的一部分转换成string，可以```new String(charArray, 0, s)```，这里0是起始index，s是这个substring的size，也就是终止index+1！这里是左闭右开区间
   - 同时char array转换成string可以调用valueOf，```String str = String.valueOf(charArray);```，只不过这个不能通过index取substring。不过再转换成string，可以再call substring，只不过时间复杂度较高。
   - 如果这个string是word separate by space，可以```s.split(" ")```这里split是exactly一个空格，如果是要满足一个或者多个，需要regex
   - 当string size频繁变化，可以使用StringBuilder，
     - append是O(1)，但是insert(i)是O(n)
     - sb.toString()转换为String
     - sb.deleteCharAt(i)删掉index为i的char，backtracing时更好的选择是sb.setLength(l)把sb固定设为size l，setLength()更好的原因是之前append可能的size不固定的string、word，setLength直接set在append之前cache下来的原来的length可以处理这种情况
     - sb.charAt(i)读取index i的char是个啥
   - string1 + string2
     - string是immutable，所以加号都会new一个新的string，慎用
   - string本身有个s.charAt(i)，只读index i的char是个啥，不能写，如果只有读的操作，可以不用上面转换的过程
   - string的s.subString()是new了一个新的string，创建的时间复杂度也是O(n)。这个要clarify是否可以使用substring。如果不让使用substring，可以使用start和end两个index来标识所操作的substring的范围，这里范围是[start, end)，同样也是左闭右开区间。如果只是用一个parameter，默认是startIndex，也就是取到的substring是当前index到最后所有的substring
5. String的各种topic
   - Reverse
   - Encode/Decode/Match
   - Deduplicate
   - Remove / replace
   - Substring
   - Permutation
   - Anagram / Palindrome / isomorphic
   - DP, Longest, Largest …
   - DFS
## Q1 Remove chars from String (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - slow fast指针
   - fast指针扫原始string，遇到要删除的直接跳过
   - slow用于创建和保留fast遇到的不要删除的
2. Comments:
   - slow所创建的这个一直在尾部加char，同时最后要求string输出，所以可以使用StringBuilder
   - 因为fast永远站在slow的前面或者重合，slow永远不会越过fast，所以可以实现inplace操作，不会有overwrite的发生，如果不是remove，是replace by 2，即特定char找到把它一个变2个，这样slow可能会越过fast，这样把fast还没check到的char给overwrite了
   - 上面这个inplace操作过程：
     - 判断cc
     - s和f起始在index 0
     - 然后check f
       - 如果是要删的，f++
       - 如果不是要删的，set s为当前f的值，s++，f++
       - 做到f == array.length时，这时f出界，result出现
   - 这个操作中:
     - [0, s) 是solution so far
     - [s, f) don't care
     - [f, array.length - 1] to do
   - 如果要从char array中的一部分转换成string，可以```new String(charArray, 0, s)```，这里0是起始index，s是这个substring的size，也就是终止index+1！
   - “s"是String，'s'是char
   - 类似quick sort partition swap方法不行，出来的结果不是stable的
3. Code
```java
public String removeChar(String s) {
	// corner case
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
    for (int fast = 0; fast < chars.length; fast++) {
        if (chars[fast] != ‘o’ && chars[fast] != ‘f’) chars[slow++] = chars[fast];
    } 
    return new String(chars, 0, slow);
}
```
## Q2 Remove leading/trailing/and duplicate space with one remaining. Trim() (L???)
1. Description
   - 实现trim()，string中最前最后space删除，中间word之间的space留一个
   - auto script格式规范化code，linter
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - 类似Q1的S1，使用slow fast指针inplace操作，这里注意处理space的问题
2. Comments:
   - 连续紧邻的duplicates
     - 保留重复的第一个？ --> 当```array[i] == array[i-1]```删除array[i]
     - 保留重复的最后一个 --> 当```array[i] == array[i+1]```删除array[i]
   - 这里保留word之间的第一个space。另一个解释保留word之间最后一个space
   - 注意i-1越界问题，当i等于0同时还是space时，这些space都要删去
   - 队尾的space要在postprocessing中处理，由于除了一开始的一波space，是默认保留第一个space，所以如果原始string末尾有space，这里出来的slow指针也会加一个space，同时也会存在原始string末尾没有space的情况。综上，要postprocessing确认下slow - 1是不是space。而这里slow - 1也可能越界，发生于input全是space的情况，这是一个corner case要提前check。
   - check slow - 1是不是space也可以等效checkfast跑完，fast - 1是不是space，其实就是check原始string中尾部是否有space
   - 这里如果是保留word之间最后那个space，就要postprocessing string之前是否有space
3. Code
保留word之间第一个space
```java
public String removeSpaces(String s) {
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
	for (int fast = 0; fast < chars.length; fast++){
		    //取非 chars[fast] != ‘ ’ || (fast != 0 && chars[fast - 1] != ‘ ’)
		if (!(chars[fast] == ‘ ’ && (fast == 0 || chars[fast - 1] == ‘ ’))) {
			chars[slow++] = chars[fast];
        }
}
	if (slow == 0) return “”;
return chars[slow - 1] == ‘ ’ ? 
		new String(chars, 0, slow - 1) : new String(chars, 0, slow);
}
```
保留word之间最后一个space
```java
public String removeSpaces(String s) {
	if (s == null || s.length() == 0) return s;

    char[] chars = s.toCharArray();
    int slow = 0;
	for (int fast = 0; fast < chars.length; fast++) {
		if (!(chars[fast] == ‘ ’ && (fast == chars.length - 1 || char[fast + 1] == ‘ ’))) {
			chars[slow++] = chars[fast];
        }	
    }
	
    if (slow == 0) return “”; // 下面那个slow - 1，所以这里要check slow == 0
    return chars[0] == ‘ ’ ? 
		new String(chars, 1, slow - 1) : new String(chars, 0, slow);
}
```
## Q3 Remove Duplicates from Sorted Array (L???)
1. Description
   - sorted，adjacent，去重留k个
2. Clarification
   - sorted，或者必须是adjacent，也就是duplicate必须连续出现
3. Follow up
   - Q3.1 Remove duplicated adjacent letters / sorted letters with one left / two left / no one left
   - Q3.2 For no one left, remove again repeatedly → stack
   - Q3.3 Sorted letters Remove duplicated letters with one left / two left / no one left
### S1
1. Ideas：
   - 依旧slow fast指针
2. Comments:
   - 这里只适用于sorted，或者adjacent，以及去重留1个，或者1个以上的情况
   - 如果留k个，k > 0，具体过程：
     - 先判断cc，如果不足k个则需要clarify，全部保留
     - slow fast初始在index k，也就是前面有k个无脑保留
     - 然后check array[fast] == array[slow - k]
     - 由于题目是adjacent，所以如果相等，slow - k到fast全都是相等的，也就是一定大于k，fast++，slow不变，因为slow此时也是等于slow - k，这时正好这个相同的取满k个
     - 当不相等时，array[slow] = array[fast]，然后slow++，fast++
     - fast走完，[0, slow)是答案；[slow, fast)已经check的，可以overwrite的；[fast, array.length - 1]是要check的
3. Code
```java
public String removeSpace(String s, int k) {
	if (s == null || s.length() <= k) {
	return s;
    }
    char[] array = s.toCharArray();
    int slow = k;

    for (int fast = k; fast < s.length(); fast++) {
        if (array[fast] == array[slow - k]) {
            continue;
        }
        else array[slow++] = array[fast];
    }
    return new String(array, 0, slow);
}

```
### S2
1. Ideas：
   - slow fast指针，只不过不同的区间定义
2. Comments:
   - [0, s] solution so far
   - (s, f) explored and i don't care / will be update or assign
   - [f, length - 1] unknown to explore
3. Code
```java
public String removeSpace_K_left_S2(String str, int k) {
	if (str == null || str.length() <= k)
		return str;
	chars[] array = str.toCharArray();
	int slow = k - 1, len = array.length();	
	for (int fast = k; fast < len; fast++) { 
        // k ＝ 1 yes, k >= 2 NO
		if (array[fast] != array[slow + 1 - k])	{
			array[++slow] = array[fast];
        }	
	}
	return new String(array, 0, slow + 1);
}
```
## Q4  L344 Reverse String → Swap (L344)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - swap, while loop
2. Comments:
   - null
3. Code
```java
public String reverseString(String s) {
	if(s == null || s.length() <= 1) return s;
	char[] array = s.toCharArray();
	int i = 0;
	int j = array.length - 1;
	while (i < j) {
		swap(array,i++,j--);
    }
    return new String(array);
}
```
### S2
1. Ideas：
   - swap, recursion
2. Comments:
   - null
3. Code
```java
public String reverse (String s){
	if ( s == null ||  s.length() < 2 ) return s;
	char[] array = s.toCharArray();
    array = help(array, 0, s.length() - 1);
    return new String(array, 0, s.length());	
}
// 先swap 后call
private char[] help( char[] array, int start, int end){ // void可以不return
	int n = end - start + 1;
	if ( start >= end) return array[start]; // wrong
	swap(array,start,end);
	return help(array, ++start, --end);

//先call 后swap
public void helper(char[] chars, int left, int right) {
	if (left >= right) return;
	helper(chars, left + 1, right - 1); 
	// wall
	swap(chars, left, right);
	// return

｝
```
## Q5 Reverse Words in a String (L151)
1. Description
   - you get offer --> offer get you
2. Clarification
   - input type?
   - space的处理情况，两个space要不要trim？前后space要不要保留？
3. Follow up
   - Q2.1 L186
   - input包含符号，即：let's go to 'New York' --> 'New York' to go Let's
     - S2可以handle，碰到引号则无脑要check到下一个引号，然后再reverse，不管中间的space
### S1
1. Ideas：
   - split to word array, reverse this word array
### S2
1. Ideas：
   - reverse globally
   - reverse words separately again to the normal order
2. Comments:
   - 注意如何用slow和fast确定一个又一个的word
   - 也可以先reverse每一个word，再全局reverse
## Q6 String Rotate / Shift (L???)
1. Description
   - http://www.lintcode.com/en/problem/rotate-string/
   - 以index k为pivot，rotate这个string。或者向右shift k位
   - e.g. input string = abcdefg, k = 3；return: efgabcd 
2. Clarification
3. Follow up
   - 如果input是single linked list？
     - 直接找到要断开的前后两个node，接上head就行
   - 如果input是queue？
     - 只能把n - k个都poll出来，这里k如果大于size的话，要k%size取个余，然后再把poll出来的offer进queue里
### S1
1. Ideas：
   - 先reverse globally
   - 然后把pivot前面和后面再分别reverse
