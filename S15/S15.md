## Array & String II
1. String就是array表示的，toCharArray()
2. StringBuilder(), dynamic length
3. str1 + str2 慎用 immutable，O(n)
4. substring() 慎用 immutable，O(n)
5. charAt
6. immutable class
   - private final field不能改变
   - 不使用setter
7. slow fast指针，fast使用for loop。同时注意slow不能越过fast，如果有可能越过，最好是自右向左slow fast，有一定的offset也可以。sliding window
8. left right两边往中间，while loop，左右越过，左右相等，左右相邻？使用swap会不stable
## Q1 Sort colors (L???)
1. Description
   - 3种color
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - general sorts
2. Comments:
   - nlogn
### S2
1. Ideas：
   - bucket/count sort
2. Comments:
   - O(n)
### S3
1. Ideas：
   - k-1次的quick sort中的partition
2. Comments:
   - O(n)
### S4
1. Ideas：
   - three pointers
2. Comments:
   - 区间定义：______i______j_____k______
     - [0, i)  	0
     - [i, j)   	1
     - [j, k]   等待被check
     - (k, ..]  	2
   - 查j，j一定要越过k，结束，所以while(j <= k)
     - 当j位置的值是0，和i位置的值swap，i++，j++
     - 当j位置的值是1，j++
     - 当j位置的值是2，和k位置的值swap，k--
## Q2 Given sorted?/ajacent array (string), deduplicate with one remaining (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q2.1 deduplicate with two/three/k remaining
     - 不adjacent只能使用hashmap
### S1
1. Ideas：
   - 使用stack，去重留一个
2. Comments:
   - pop出来用StringBuilder，再reverse一下
3. Code
```java
public String deduplicate(String input) {
	if (input == null || input.length() <= 1) return input;
	Stack<Character> stack = new Stack<>();
	for(int i = 0; i < input.length(); i++) {
		if (stack.empty() || stack.peek() != input.charAt(i)) {
            stack.push(input.charAt(i));
        }
	}
	String result = “”;
	while (!stack.empty()) {
		result = Character.toString(stack.pop()) + result;
	}
	return result;
}
```
### S2
1. Ideas：
   - 只用StringBuilder
2. Comments:
   - S1中的stack只是中间checkduplicate作用，StringBuilder可以起到相同的作用
3. Code
```java
//remove duplicate character (keep 1) in string
public String removeDup(String s) {
	if (s == null || s.length() < 2) return s;
	StringBuilder sb = new StringBuilder();
	// Stack<Character> st = new Stack<Character>();
	for (char c: s.toCharArray()) {
		// if (st.isEmpty() || c != st.peek()) {st.push(c); sb.append(c);
		if (sb.length() == 0 || c != sb.charAt(sb.length() - 1)) sb.append(c);
	}
	return sb.toString();
}
```
### Q2.1 S1
1. Ideas：
   - slow fast
2. Comments:
   - input必须adjacent
3. Code
```java
public int deduplicate(int[] arr) {
	// arr == null
	if (arr.length <= k) return arr.length// because fast starts from 1, consider this corner case
	int slow = k;
	for(int fast = k; fast < arr.length; fast++) {
		if(arr[slow - k] != arr[fast]) {
			arr[slow++] = arr[fast];
}
	}
	return slow; // length of solution
}
```
## Q3 Given sorted/ajacent？ array (string), deduplicate with zero remaining
1. Description
   - 连续的都要去掉
   - 如果不是adjacent，比如 1 4 2 2 2 4 3，2去掉了，两个4连在一起，同理还要去掉，最后是1 3
2. Clarification
   - null
3. Follow up
   - Q3.1 Given unsorted String, deduplicate adjacent letters repeatedly
     - 比如 1 4 2 2 2 4 3，2去掉了，两个4连在一起，同理还要去掉，最后是1 3
     - recursively do
### S1
1. Ideas：
   - hashmap
2. Comments:
   - 必须是adjacent
### S2
1. Ideas：
   - stack加一个flag记录是重复还是只有一个
2. Comments:
   - 当来的和stack栈顶是一样的，flag设为true
   - 等来的element不一样，先看flag是不是true，
     - 是true，pop出栈顶的值，再把新的塞进去，把flag reset成false
     - 如果是false，直接塞
### S3
1. Ideas：
   - slow fast + flag同理
2. Comments:
   - null
3. Code
```java
private static int dedupWithNoRemaining(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    
    int slow = 1, fast;
    boolean flag = false;
    
    for (fast = 1; fast < nums.length; fast++) {
        if (nums[slow - 1] != nums[fast]) {
            if (flag) { // flag is true means slow index value shoud be deleted
                nums[slow - 1] = nums[fast];
                flag = false;
            } else {   
                nums[slow++] = nums[fast];
            }
        } else {
            flag = true;
        }
    }
   	 
   	 // postprocessing
   	 return flag ? slow - 1 : slow;
}
```
## Q4 Move zeros
1. Description
   - stable (不能用quick sort的partition)
2. Clarification
   - 非0也要不要求stable？
     - 不要求，S1
   - sort two
3. Follow up
   - sort three --> sort k
### S1
1. Ideas：
   - slow fast指针同步走，swap
2. Comments:
   - 可以保证非0的数是stable的，0不一定是stable的
### S2
1. Ideas：
   - 类似S1的slow fast，不过不用swap，直接赋值
2. Comments:
   - slow找到0，fast找到非0，slow直接赋值fast那个值
   - 最后[0, slow)就是答案，要0可以[slow, fast)补零
## Q5 Given unsorted array, find largest and smallest number with least comparision (L???)
1. Description
   - least comparison
   - 类比淘汰赛决冠军和最后一名
2. Clarification
   - null
3. Follow up
   - Q5.1 find largest k numbers
     - min heap
   - Q5.2 find larget k and smallest l numbers
     - min heap + max heap
   - Q5.3 Given n numbers, plus them with least operation +
   - Q5.4 Given unsorted array, find largest and second largest number with least comparision
     - brutal force 两个global max，2n次comparison
     - binary reduction recursively
       - 首先两两对决得到冠军，对决的同时记录每个队胜利时打过的队 n/2 + n/4 + n/8 + ... + 2 + 1 = n - 1
       - 冠军打败的队中一定有第二强的
       - 对这些被冠军打败的队(logn 个）再次两两对决，取得真正第二强的队 logn/2 + ... + 2 + 1 = logn - 1
       - 总的比赛次数：n - 1 + logn - 1
     - 不一定两两对决，可以三个三个，看个k个，下面田忌赛马5个5个
   - Q5.5 田忌赛马 最小次数决出胜负 k赛道： 5个跑道，25匹马，找前3名，最小比赛次数 
      - refer to leetcode 4 → external sort。跑道：内存；马：数据；找前三：前三大，sort
      - 分为5个group，跑5下
      - 把每个group的冠军的五个进入晋级赛再跑一下，决出冠军
      - 最后把冠军的group的第二第三，晋级赛第二和晋级赛第二的group的第二，晋级赛第三的跑一下，决出第二和第三
### S1
1. Ideas：
   - binary reduction
2. Comments:
   - step1: compare each pair of elements, put all larger elements into larger group, put all smaller elements into smaller group
   - step2: for loop larger group to find the largest. for loop smaller group to find the smallest
   - 这里第二步直接用比较两个更新global min/max for loop整个去找，第一步淘汰一半，比较了n/2次，第二步分别找最大最小各比较n/2，总共花费3n/2
   - 如果这里step2依然继续比较，也就是赢得那个半区再互相比较，得到胜利的n/4，把剩下的n/4丢掉；同理输的半区也得到n/4，不断recursion做，比较次数的花费：n/2 + n/4 + n/4 + n/8 + n/8 + ... = 3n/2
   - 很神秘，比较次数一样的。感觉是两个关键，一个是要最大和最小值，第二，一劈为二，最大的和最小的分开了
## Q6 L48 2D matrix rotate by 90 180 270 clockwise or counter clockwise
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q6.1 2D matrix print by spiral
   - Q6.2 how about rectangle? → Matrix
### S1
1. Ideas：
   - null
2. Comments:
   - null
## Q7 Sort an array by the order defined by another array
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null





## Q1 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null



