## General
1. shallow copy vs. deep copy
   - reference copy vs. value copy
   - array.clone，deep copy的是第一层array的所有val，也就是说如果array里放的是一堆object，只能copy这些object的reference，无法dereference到object里面的val
2. 
## Q1 L138 Copy List with forward Pointer(L???)
1. Description
   - skipList，forward field，往后指，跳过很多的node，加快索引速度
   - ListNode有个forward field，随机指向任何一个前方的ListNode
2. Clarification
   - null
3. Follow up
   - Q1.1 Deep Copy single linked list
     - 可以two pass deep copy，使用hashmap保存原始到新的deep copy的node的对应关系
     - one pass deep copy，错位
       - 原始：1 -> 2 -> 3 -> null
       - copy:1'-> 2'-> 3'-> null
       - cur指向2，cur'指向1‘
       - 先new一个2’
       - 把cur'.next指向这个新的2'
       - 然后cur next，cur' next
   - Q1.2 Deep Copy list with random pointer
     - random 随机指针
     - 所有solution都可以
   - Q1.3 deep copy tree
     - 相对于skiplist，有些ListNode入度为2，会有查重的问题
     - TreeNode入度一定为1，遍历原始Tree，new新的TreeNode就行了
     - 自下向上，有了child才能把deep copy的TreeNode接起来
   - Q1.4 deep copy graph
     - clarify：连通？有向无向？
     - GraphNode
     - Use hashMap to de duplicate
     - Hashmap    key = reference    value new node reference
     - 1 do not visit the node we already copied
     - 2 for new pointer, check if we already have the reference in the hashmap
     - S1: DFS	recrusion + hashmap
     - S2: BFS	graph + queue + hashmap
### S1
1. Ideas：
   - two pass 使用hashmap 存cur到cur'的关系
   - first pass; build the hashmap for the relationship from the original node to the new node;
2. Comments:
   - for()   map.get(cur).next = map.get(cur.next)
   - for()   map.get(cur).forward = map.get(cur.forward)
### S2
1. Ideas：
   - two pass, no need to check target node exists or not
   - first pass, 错位update next
   - second pass, 错位update forward
2. Comments:
   - null
### S3
1. Ideas：
   - one pass
   - 使用hashmap记录cur到cur'的对应关系，用于确定cur.next历史上有没有被copy过，copy过直接从hashmap拿到被copy的ListNode
2. Comments:
   - null
3. Code
```java
ListNode dummy = new ListNode(0);
ListNode cur1 = head;
ListNode cur2 = dummy;
while (cur1 != null) {// cur → dummy 
	if (!map.containsKey(cur1) {
		map.put(cur1, new ListNode(cur1.value));
    }
    // 这里无脑map.get，因为前面保证map里能get出来
    cur2.next = map.get(cur1); 

    if (cur1.forward != null) {
        if (!map.containsKey(cur1.forward)) {
            map.put(cur1.forward, new Listnode(cur1.forward.value));
        }
        //
        cur2.next.forward = map.get(cur1.forward);
    }
	
	cur1 = cur1.next;
	cur2 = cur2.next;
}
```
### S4
1. Ideas：
   - three pass
2. Comments:
   - first pass：在cur后面deep copy 一个cur'：1 -> 2 -> 3 -> null， 1 -> 1' -> 2 -> 2' -> 3 -> 3' -> null
   - second pass：cur的forward，deep copy到cur'的forward，cur.next.forward = cur.forward.next
   - third pass：奇偶partition
## Q2 L270 L272 Closest Binary Search Tree Value (L???)
1. Description
   - Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.
   - Given target value is a floating point
   - You are guaranteed to have only one unique value in the BST that is closest to the target（可能有两个，比target小，或者比target大）
2. Clarification
   - 给的val是不是和tree里的val的数据类型一致？
     - double相等是用两者之差小于一个很小的epsilon
3. Follow up
   - Q2.1 K Closest Binary Search Tree Value
     - 转换成array做k closest element in array
     - tree的难点在于怎么定位BST的前一个和后一个，可以使用stack while loop遍历tree来解决
     - 另外，这题可以转换成top k，遍历过程中keep k 个离target最近的k个
### S1
1. Ideas：
   - 遍历tree，从root到leaf node，只有一条路径
2. Comments:
   - 使用global var记录cur closest val
   - S: use a global_closest to store the closest diff / value / node (high level wrapper)
   - case1: if cur.value > target, update global_closest if needed, move cur to cur.left;
   - case2: if cur.value < target, update global_closest if needed, move cur to cur.right
   - case3: if cur.value == target, return target
3. Code
```java
public int closestValue(TreeNode root, double target) {
	  if (root == null) return 0; // throw new Excepetion()
        int closest = root.val; // null
        while(root != null){
		if (target == root.val) return root.val; // not must
            if(Math.abs(target - root.val) < Math.abs(target - closest.val))
                closest = root.val;
            root = root.val > target ? root.left : root.right;
        }
       return closest;
    }
```
## Q3 Largest Smaller Binary Search Tree Value OR largest smaller or equals (L???)
1. Description
   - 比target小的最大的
2. Clarification
   - 可能没有，所有node都比target大
3. Follow up
   - equals?
     - case3: if cur.value == target, return target
   -  Smallest Larger Binary Search Tree Value 
### S1
1. Ideas：
   - tree的遍历
   - 一条路走到底的leaf
2. Comments:
   - case1: if cur.value >= target,move cur to cur.left;
   - case2: if cur.value < target, update global_closest if needed, move cur to cur.right

3. Code
```java
public TreeNode findLargestSmaller(TreeNode root, double target) {
	if (root == null) return Integer.MIN_VALUE; //?
    TreeNode closest = root; // null
    while (root != null) {
        if (root.val < target) {
            if (root.val > closest.val) {
                closest = root;
            }
            root = root.right;
        } else {
            root = root.left;
        }
    }
    if (closest.val > target) return null; // 说明所有node都比target大
    return closest; // check root vs target
}
```
## Q4 L450 Remove target from BST (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - recursion找，删
2. Comments:
   - case 1: root.val == target
     - case a: if root has both lchild and rchild,  find smallest element from right subtree( or find the largest element from the left subtree), say x, assign x's value to root, remove x's value from the right subtree by recursion
     - case b: if root has only one child, iff has one child, replace root with non-null child / parent connect directly to child.
     - case c: if root has no child, remove self / root = null;
   - case 2: root.val > target, go to left subtree by recursion
   - case 3: root.val < target, go to right subtree by recursion
3. Code
```java
public TreeNode removeAndReturn(TreeNode root, int target) {
	// corner case

	if (root.val == target) {
		if (root.left != null && root.right != null) {
			root.val = findMin(root.right).val;
			root.right = removeAndReturn(root.right, root.val);
		} else {
			root = root.left != null ? root.left : root.right
		}
	} else if (root.val > target) {
		root.left = removeAndReturn(root.left, target)
	} else {
		root.right = removeAndReturn(root.right, target)
	}
	return root;
}
```
## Q5 L701 Insert target into BST (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q6.1 update target into BST
     - 可以先删掉，在insert
### S1
1. Ideas：
   - Keypoint: please maintain a parent node / previous node
   - prev + cur
   - cur → prev.next
2. Comments:
   - vs recursion
   - null
## Q6 L156 Binary Tree Upside Down → only upside down (L???)
1. Description
   - Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.
2. Clarification
   - 右边child只可能是leaf node
   - 形态转变最好是node不变，变reference
3. Follow up
   - Q6.1 Reverse Linked List
### S1
1. Ideas：
   - recursion
   - 先call后办事
2. Comments:
   - 类似reverse single linked list
   - ![16-1](Fig16-1.png)
3. Code
```java
public TreeNode reverse(TreeNode root) {
	if (root == null) return null;
	if (root.left == null) return root;
	TreeNode newRoot = reverse(root.left);
	root.left.left = root.right;
	root.left.right = root;
	root.left = null;
	root.right = null;
	return newRoot;

}
```
## Q7 Stone Cut (L???)
1. Description
   - n stone, mark the possible cutable position at cut[], 每次切的时候被切的整体的长度就是cost，求把cut[]全部切完的最小cost
   - ![16-2](Fig16-2.png)
2. Clarification
   - null
3. Follow up
   - Q7.1 Stone merge
     - 一堆石头，两两merge，merge时两个石头的重量只和就是cost，求cost最小的全部merge
     - 只有相邻可以merge
     - 任意两个merge还是只能相邻两个merge？
       - 如果是任意，就直接选最小的两个merge，然后再选最小的两个（包含之前merge的结果），使用heap，merge完丢进去
     - 如果只能相邻，
     - 使用dp：
       - dp[i][j] the smallest cost to deal with the stone from i to j
       - dp[i][j] = cost(i, j) + min(dp[i][k] + dp[k][j]) for every possible k
     - 很类似stone cut的从小到大的过程。stone cut是从大到小。
### S1
1. Ideas：
   - dfs
2. Comments:
   - 每次决定切在哪
   - 答案出在最后
   - 更新global min val
   - dfs处理的是局部的[i, j]，也就是2D的dfs
     - dfs[i, j] = cost[i, j] + min(dfs[i, k] + dfs[k, j])
   - 这里局部的[i, j]有大量冗余计算，所以可以用dp
### S2
1. Ideas：
   - dp
2. Comments:
   - base case:
     - dp[0][1] = 0
     - dp[1][2] = 0
     - dp[2][3] = 0
     - dp[3][4] = 0
   - some examples:
     - dp[0][2] = 6 + dp[0][1] + dp[1][2]
     - dp[0][3] = case1: 9 + dp[0][1] + dp[1][3]
                  case2: 9 + dp[0][2] + dp[2][3]
   - definition：dp[i][j] the smallest cost to deal with the stone from i to j
   - induction rule：dp[i][j] = cost(i, j) + min(dp[i][k] + dp[k][j]) for every possible k
## Q8 L20 Valid ParentTheses (L???)
1. Description
   - 判断是否括号有效？
   - 即左括号要和右括号匹配；左括号和右括号个数相等
2. Clarification
   - 有几种括号？
3. Follow up
   - Q8.1 Valid permutation of n pairs ()
     - dfs + pruning
     - 使用left_so_far和right_so_far来check，同时left_so_far不能大于n
   - Q8.2 Valid permutation of n pairs (), m pairs [], p pairs {}
     - dfs + pruning
     - 使用StringBuilder（类似stack）达到check valid的作用实现提前剪枝
     - 注意backtracing的问题
   - Q8.3 Valid xml / html
     - 本质就是多种type的括号
     - 使用stack
   - Q8.4 palindrome break
### S1
1. Ideas：
   - one pass with number of ( ) and then check==
   - 1 left_so_far >= right_so_far
   - 2 left_total == right_total
2. Comments:
   - 括号type只能是一种
### S2
1. Ideas：
   - stack
2. Comments:
   - 可以处理多种括号
   - case1: if ( [ { push it into stack
   - case2: else if stack top matched → pop() (empty?) else not matched → return false;
## Q9 Sorted/Ajacent String Permutation with/without duplicate (L???)
1. Description
   - 有重复，不保证adjacent
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - dfs + swap
   - 重复：只取重复的第一个（由adjacent保证）
     - 这里由于采用swap，所以adjacent等于没用，无法使用i和i-1进行比较，要使用hashset来check 
   - 跳叉 --> 跳for loop，使用if + continue
     - while 和i++：如果后面都是duplicate，i会加出界
2. Comments:
   - null
## Q10 Subsets {1 2 3} (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q13.1 divide set into 2 groups with equal sum up (ebay) → k (NP problem)
     - 即不可以从小到大greedy分，也不能从大到小greedy分
     - all possible subset, match sum/2
   - Q13.2 Subset II all subsequence of sorted string // reference to next session
     - sorted + subsequence = unsorted subset。anagram，一堆subset选个代表就是sorted之后的subsequence
     - 这里如果问的是unsorted subset，可以先sort之后，求all possible subsequence
### S1
1. Ideas：
   - dfs
   - 第i层表示index i取哪个element
2. Comments:
   - 由于有重复，需要跳过一些重复的element，这里就是跳叉，也就是for loop跳，使用if+continue
   - 重复时永远取第一个
### S2
1. Ideas：
   - dfs
   - 第i层表示原始给的array的第i个取还是不取
2. Comments:
   - 这里重复依旧选第一个，但是重复的只取第一个，比如第i层，则我们要跳过i+1层等重复的层
   - 跳层
3. Code
```java
// if we decide on all positions
// we have a complete subset, all subset locate on the leaf node
if (index == array.length) {
    result.add(sb.toString());
    return;
}
// case1. add character at index;
sb.append(array[index]);
helper(array, sb, index + 1, result);

// wall
// remove the added character when backtracking to the upper level
sb.deleteCharAt(sb.length() - 1);

while ( index < input.lenght - 1 && input[index] == input[index + 1]) index++;
// case2. NOT add character at index
helper(array, sb, index + 1, result);  
```
## Q11 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null




## Q1 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null
3. Code
