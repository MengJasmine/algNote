## General
1. shallow copy vs. deep copy
   - reference copy vs. value copy
   - array.clone，deep copy的是第一层array的所有val，也就是说如果array里放的是一堆object，只能copy这些object的reference，无法dereference到object里面的val
2. 
## Q1 L138 Copy List with forward Pointer(L???)
1. Description
   - skipList，forward field，往后指，跳过很多的node，加快索引速度
   - ListNode有个forward field，随机指向任何一个前方的ListNode
2. Clarification
   - null
3. Follow up
   - Q1.1 Deep Copy single linked list
     - 可以two pass deep copy，使用hashmap保存原始到新的deep copy的node的对应关系
     - one pass deep copy，错位
       - 原始：1 -> 2 -> 3 -> null
       - copy:1'-> 2'-> 3'-> null
       - cur指向2，cur'指向1‘
       - 先new一个2’
       - 把cur'.next指向这个新的2'
       - 然后cur next，cur' next
   - Q1.2 Deep Copy list with random pointer
     - random 随机指针
     - 所有solution都可以
   - Q1.3 deep copy tree
     - 相对于skiplist，有些ListNode入度为2，会有查重的问题
     - TreeNode入度一定为1，遍历原始Tree，new新的TreeNode就行了
     - 自下向上，有了child才能把deep copy的TreeNode接起来
   - Q1.4 deep copy graph
     - clarify：连通？有向无向？
     - GraphNode
     - Use hashMap to de duplicate
     - Hashmap    key = reference    value new node reference
     - 1 do not visit the node we already copied
     - 2 for new pointer, check if we already have the reference in the hashmap
     - S1: DFS	recrusion + hashmap
     - S2: BFS	graph + queue + hashmap
### S1
1. Ideas：
   - two pass 使用hashmap 存cur到cur'的关系
   - first pass; build the hashmap for the relationship from the original node to the new node;
2. Comments:
   - for()   map.get(cur).next = map.get(cur.next)
   - for()   map.get(cur).forward = map.get(cur.forward)
### S2
1. Ideas：
   - two pass, no need to check target node exists or not
   - first pass, 错位update next
   - second pass, 错位update forward
2. Comments:
   - null
### S3
1. Ideas：
   - one pass
   - 使用hashmap记录cur到cur'的对应关系，用于确定cur.next历史上有没有被copy过，copy过直接从hashmap拿到被copy的ListNode
2. Comments:
   - null
3. Code
```java
ListNode dummy = new ListNode(0);
ListNode cur1 = head;
ListNode cur2 = dummy;
while (cur1 != null) {// cur → dummy 
	if (!map.containsKey(cur1) {
		map.put(cur1, new ListNode(cur1.value));
    }
    // 这里无脑map.get，因为前面保证map里能get出来
    cur2.next = map.get(cur1); 

    if (cur1.forward != null) {
        if (!map.containsKey(cur1.forward)) {
            map.put(cur1.forward, new Listnode(cur1.forward.value));
        }
        //
        cur2.next.forward = map.get(cur1.forward);
    }
	
	cur1 = cur1.next;
	cur2 = cur2.next;
}
```
### S4
1. Ideas：
   - three pass
2. Comments:
   - first pass：在cur后面deep copy 一个cur'：1 -> 2 -> 3 -> null， 1 -> 1' -> 2 -> 2' -> 3 -> 3' -> null
   - second pass：cur的forward，deep copy到cur'的forward，cur.next.forward = cur.forward.next
   - third pass：奇偶partition
## Q2 L270 L272 Closest Binary Search Tree Value (L???)
1. Description
   - Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.
   - Given target value is a floating point
   - You are guaranteed to have only one unique value in the BST that is closest to the target（可能有两个，比target小，或者比target大）
2. Clarification
   - 给的val是不是和tree里的val的数据类型一致？
     - double相等是用两者之差小于一个很小的epsilon
3. Follow up
   - Q2.1 K Closest Binary Search Tree Value
     - 转换成array做k closest element in array
     - tree的难点在于怎么定位BST的前一个和后一个，可以使用stack while loop遍历tree来解决
     - 另外，这题可以转换成top k，遍历过程中keep k 个离target最近的k个
### S1
1. Ideas：
   - 遍历tree，从root到leaf node，只有一条路径
2. Comments:
   - 使用global var记录cur closest val
   - S: use a global_closest to store the closest diff / value / node (high level wrapper)
   - case1: if cur.value > target, update global_closest if needed, move cur to cur.left;
   - case2: if cur.value < target, update global_closest if needed, move cur to cur.right
   - case3: if cur.value == target, return target
3. Code
```java
public int closestValue(TreeNode root, double target) {
	  if (root == null) return 0; // throw new Excepetion()
        int closest = root.val; // null
        while(root != null){
		if (target == root.val) return root.val; // not must
            if(Math.abs(target - root.val) < Math.abs(target - closest.val))
                closest = root.val;
            root = root.val > target ? root.left : root.right;
        }
       return closest;
    }
```
## Q3 Largest Smaller Binary Search Tree Value OR largest smaller or equals (L???)
1. Description
   - 比target小的最大的
2. Clarification
   - 可能没有，所有node都比target大
3. Follow up
   - equals?
     - case3: if cur.value == target, return target
   -  Smallest Larger Binary Search Tree Value 
### S1
1. Ideas：
   - tree的遍历
   - 一条路走到底的leaf
2. Comments:
   - case1: if cur.value >= target,move cur to cur.left;
   - case2: if cur.value < target, update global_closest if needed, move cur to cur.right

3. Code
```java
public TreeNode findLargestSmaller(TreeNode root, double target) {
	if (root == null) return Integer.MIN_VALUE; //?
    TreeNode closest = root; // null
    while (root != null) {
        if (root.val < target) {
            if (root.val > closest.val) {
                closest = root;
            }
            root = root.right;
        } else {
            root = root.left;
        }
    }
    if (closest.val > target) return null; // 说明所有node都比target大
    return closest; // check root vs target
}
```
## Q4 L450 Remove target from BST (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - recursion找，删
2. Comments:
   - case 1: root.val == target
     - case a: if root has both lchild and rchild,  find smallest element from right subtree( or find the largest element from the left subtree), say x, assign x's value to root, remove x's value from the right subtree by recursion
     - case b: if root has only one child, iff has one child, replace root with non-null child / parent connect directly to child.
     - case c: if root has no child, remove self / root = null;
   - case 2: root.val > target, go to left subtree by recursion
   - case 3: root.val < target, go to right subtree by recursion
3. Code
```java
public TreeNode removeAndReturn(TreeNode root, int target) {
	// corner case

	if (root.val == target) {
		if (root.left != null && root.right != null) {
			root.val = findMin(root.right).val;
			root.right = removeAndReturn(root.right, root.val);
		} else {
			root = root.left != null ? root.left : root.right
		}
	} else if (root.val > target) {
		root.left = removeAndReturn(root.left, target)
	} else {
		root.right = removeAndReturn(root.right, target)
	}
	return root;
}
```
## Q5 L701 Insert target into BST (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - Q6.1 update target into BST
### S1
1. Ideas：
   - null
2. Comments:
   - null



## Q1 (L???)
1. Description
   - null
2. Clarification
   - null
3. Follow up
   - null
### S1
1. Ideas：
   - null
2. Comments:
   - null
3. Code
